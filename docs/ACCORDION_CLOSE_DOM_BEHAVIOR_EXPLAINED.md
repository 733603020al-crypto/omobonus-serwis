# Объяснение поведения DOM при закрытии подкатегории аккордеона

**Дата анализа:** текущая версия кода после упрощения логики

**Проблема:** При закрытии подкатегории страница визуально возвращается к позиции, которая была **до открытия**, хотя мы убрали всю логику сохранения/восстановления скролла.

---

## 1️⃣ Цепочка шагов при закрытии подкатегории

### Шаг 1: Пользователь кликает на заголовок открытой подкатегории

**Действие:** Клик на `AccordionTrigger` открытой подкатегории

**Код:** `src/app/uslugi/service-accordion.tsx`, строка 1587-1592
```typescript
const handleSubcategoryChange = (sectionId: string, value: string | null) => {
  if (sectionId !== 'naprawy') return
  // Просто изменяем состояние - при закрытии браузер естественно обработает изменение высоты
  setOpenSubcategory(prev => (prev === value ? null : value))
}
```

**Что происходит:**
- Radix UI Accordion получает `onValueChange(null)`
- Вызывается `handleSubcategoryChange('naprawy', null)`
- Выполняется `setOpenSubcategory(null)`

---

### Шаг 2: React обновляет состояние и запускает ре-рендер

**Что происходит:**
- React планирует ре-рендер компонента
- `openSubcategory` меняется с `ID подкатегории` на `null`
- Компонент `Accordion` получает новое значение `value={undefined}`

---

### Шаг 3: Radix UI Accordion обновляет DOM

**Местоположение:** `src/components/ui/accordion.tsx`, строка 56-62

**Что делает Radix UI:**

1. **Обновляет атрибут `data-state` на `AccordionItem`:**
   - Было: `data-state="open"`
   - Стало: `data-state="closed"`

2. **Обновляет атрибут `data-state` на `AccordionContent`:**
   - Было: `data-state="open"`
   - Стало: `data-state="closed"`

3. **Применяет CSS классы:**
   - `AccordionContent` получает класс `animate-accordion-up` (вместо `animate-accordion-down`)
   - Класс применяется через: `data-[state=closed]:animate-accordion-up`

---

### Шаг 4: CSS анимация закрытия

**Местоположение:** `src/components/ui/accordion.tsx`, строка 58

**Класс:** `animate-accordion-up` (предоставляется через `tw-animate-css`)

**Что делает анимация:**
- Плавно уменьшает высоту `AccordionContent` от полной высоты до 0
- Время анимации: ~200-300ms
- Использует CSS `transition` или `animation` для изменения `height` / `max-height`

**Важно:** Анимация изменяет **высоту элемента**, что влияет на общую высоту страницы.

---

### Шаг 5: Изменение высоты DOM элементов

**Структура DOM:**

```
AccordionItem (подкатегория) [data-state="closed"]
  ├─ AccordionTrigger (заголовок подкатегории)
  └─ AccordionContent [data-state="closed", height уменьшается]
     └─ div (внутренний контейнер с overflow-y-auto, max-h-[70vh])
        └─ AccordionContent контент (таблицы, текст)
```

**Что происходит:**

1. **AccordionContent уменьшается в высоте:**
   - Было: полная высота контента (например, 800px)
   - Становится: 0px (через CSS анимацию)

2. **Внутренний div с `overflow-y-auto` также уменьшается:**
   - `max-h-[70vh]` больше не ограничивает, так как родитель уменьшается
   - Контент внутри становится невидимым

3. **Общая высота секции "naprawy" уменьшается:**
   - Высота секции = сумма высот всех подкатегорий
   - Когда одна подкатегория закрывается, общая высота секции уменьшается

4. **Элементы ниже закрытой подкатегории подтягиваются вверх:**
   - Следующие подкатегории в списке
   - Секции ниже секции "naprawy"
   - Footer и другие элементы страницы

---

### Шаг 6: Поведение браузера при изменении высоты контента

**⚠️ КЛЮЧЕВОЙ МОМЕНТ:** Здесь происходит то, что вызывает возврат к старой позиции.

**Алгоритм браузера (Scroll Anchoring):**

Современные браузеры используют механизм **Scroll Anchoring** для сохранения видимости контента при изменении высоты страницы. Алгоритм работает так:

1. **Браузер определяет "якорный элемент" (anchor element):**
   - Это элемент, который был виден в viewport до изменения высоты
   - Обычно это элемент, который находится в верхней части видимой области или в фокусе

2. **При изменении высоты контента:**
   - Браузер пытается сохранить видимость якорного элемента
   - Если контент выше якорного элемента уменьшается, браузер **автоматически прокручивает страницу вверх**, чтобы якорный элемент остался видимым

3. **Проблема в нашем случае:**
   - Когда мы открыли подкатегорию, мы программно прокрутили страницу так, чтобы заголовок подкатегории был под заголовком секции
   - Это изменило `window.scrollY` на новое значение (например, 1500px)
   - **Якорным элементом** стал заголовок подкатегории или элемент рядом с ним
   - Когда подкатегория закрывается и её высота уменьшается, браузер видит, что якорный элемент "прыгает" вверх
   - Браузер пытается сохранить видимость якорного элемента, **прокручивая страницу вверх** на величину уменьшения высоты

**Пример:**

```
До открытия:
- window.scrollY = 1000px
- Заголовок подкатегории "Oprogramowanie" находится на позиции 1000px от верха страницы

После открытия (scrollSubcategoryToTop):
- window.scrollY = 1500px (прокрутили, чтобы заголовок был под заголовком секции)
- Заголовок подкатегории теперь на позиции ~120px от верха viewport
- Якорный элемент = заголовок подкатегории или элемент рядом

При закрытии:
- AccordionContent уменьшается на 800px (высота контента)
- Браузер видит, что якорный элемент "прыгает" вверх на 800px
- Браузер автоматически прокручивает страницу вверх на ~800px
- window.scrollY становится ~700px (1500 - 800)
- Визуально страница возвращается к позиции, близкой к той, что была до открытия
```

---

## 2️⃣ Какая часть разметки или стилей заставляет viewport вернуться к прежнему виду?

### 2.1 CSS анимация animate-accordion-up

**Местоположение:** `src/components/ui/accordion.tsx`, строка 58

**Код:**
```typescript
className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm"
```

**Что делает:**
- Изменяет высоту `AccordionContent` от полной до 0
- Это изменение высоты **триггерит Scroll Anchoring** в браузере

**Вывод:** ✅ CSS анимация `animate-accordion-up` **прямо вызывает** изменение высоты, которое активирует Scroll Anchoring.

### 2.2 Структура DOM с вложенными контейнерами

**Проблемная структура:**

```
AccordionContent [height уменьшается]
  └─ div [max-h-[70vh] overflow-y-auto] ← внутренний скроллируемый контейнер
     └─ Контент подкатегории (таблицы)
```

**Проблема:**
- Внутренний `div` с `overflow-y-auto` имеет `max-h-[70vh]`
- Когда `AccordionContent` уменьшается, внутренний `div` также уменьшается
- Это создает **двойное изменение высоты**: внешний контейнер + внутренний контейнер
- Браузер видит значительное изменение высоты и более агрессивно применяет Scroll Anchoring

**Вывод:** ✅ Вложенная структура с `overflow-y-auto` **усиливает** эффект Scroll Anchoring.

### 2.3 Глобальный scroll-behavior: smooth

**Местоположение:** `src/app/globals.css`, строка 7

**Код:**
```css
html {
  scroll-behavior: smooth;
  scroll-padding-top: 65px;
}
```

**Влияние:**
- `scroll-behavior: smooth` делает **плавной** автоматическую прокрутку, вызванную Scroll Anchoring
- Это делает возврат к старой позиции **более заметным** (плавный, а не мгновенный)

**Вывод:** ⚠️ `scroll-behavior: smooth` **не вызывает** возврат, но делает его **более заметным**.

### 2.4 Класс scroll-smooth на AccordionContent

**Местоположение:** `src/app/uslugi/service-accordion.tsx`, строка 2167

**Код:**
```typescript
className="... overflow-y-auto scroll-smooth accordion-scroll ..."
```

**Влияние:**
- `scroll-smooth` влияет только на прокрутку **внутри контейнера** (`overflow-y-auto`)
- Не влияет на прокрутку страницы при закрытии

**Вывод:** ✅ `scroll-smooth` **не влияет** на возврат к старой позиции страницы.

### 2.5 Класс scroll-mt на AccordionItem

**Местоположение:** `src/app/uslugi/service-accordion.tsx`, строка 2182

**Код:**
```typescript
className={cn(
  "border-0 last:border-b-0 last:mb-0 group scroll-mt-[100px]",
  ...
)}
```

**Что делает:**
- `scroll-mt-[100px]` устанавливает `scroll-margin-top: 100px` на `AccordionItem`
- Это создает "отступ" при прокрутке к элементу через `scrollIntoView()` или якорные ссылки

**Влияние на закрытие:**
- ⚠️ `scroll-margin-top` **может влиять** на определение якорного элемента в Scroll Anchoring
- Браузер может учитывать `scroll-margin-top` при расчете позиции якорного элемента
- Это может усиливать эффект возврата к старой позиции

**Вывод:** ⚠️ `scroll-mt-[100px]` **может влиять** на поведение Scroll Anchoring, но не является основной причиной возврата.

---

## 3️⃣ Гипотеза: почему визуально всё "отскакивает" назад

### 3.1 Механизм Scroll Anchoring

**Как работает Scroll Anchoring:**

1. **Определение якорного элемента:**
   - Браузер выбирает элемент, который был виден в верхней части viewport
   - В нашем случае это может быть:
     - Заголовок подкатегории (AccordionTrigger)
     - Элемент внутри открытого контента
     - Элемент рядом с открытым контентом

2. **Отслеживание позиции якорного элемента:**
   - Браузер запоминает позицию якорного элемента относительно viewport
   - Например: якорный элемент находится на 120px от верха viewport

3. **При изменении высоты контента:**
   - Если контент выше якорного элемента уменьшается на X пикселей
   - Якорный элемент "прыгает" вверх на X пикселей
   - Браузер автоматически прокручивает страницу вверх на X пикселей, чтобы сохранить позицию якорного элемента

4. **Результат:**
   - `window.scrollY` уменьшается на величину уменьшения высоты
   - Визуально страница возвращается к позиции, близкой к той, что была до открытия

### 3.2 Почему возврат происходит именно к "старой" позиции?

**Ключевой момент:** Браузер **НЕ помнит** старую позицию скролла. Вместо этого он использует **алгоритм сохранения видимости якорного элемента**.

**Что происходит:**

1. **До открытия:**
   - `window.scrollY = 1000px`
   - Заголовок подкатегории находится на позиции 1000px от верха страницы
   - Якорный элемент = какой-то элемент на позиции ~1000px

2. **После открытия (scrollSubcategoryToTop):**
   - `window.scrollY = 1500px` (прокрутили вниз)
   - Заголовок подкатегории теперь на позиции ~120px от верха viewport
   - Якорный элемент = заголовок подкатегории или элемент рядом

3. **При закрытии:**
   - Высота контента уменьшается на 800px
   - Якорный элемент (заголовок подкатегории) "прыгает" вверх на 800px
   - Браузер прокручивает страницу вверх на 800px
   - `window.scrollY = 1500 - 800 = 700px`

4. **Почему это похоже на "старую" позицию:**
   - Если до открытия было 1000px, а после закрытия стало 700px
   - Разница невелика (300px)
   - Визуально кажется, что вернулись к старой позиции
   - На самом деле браузер просто сохраняет видимость якорного элемента

### 3.3 Влияние вложенного контейнера с overflow-y-auto

**Дополнительный фактор:**

Внутренний `div` с `overflow-y-auto` и `max-h-[70vh]` создает **дополнительную сложность**:

1. Когда `AccordionContent` закрывается, внутренний `div` также уменьшается
2. Это создает **каскадное изменение высоты**: внешний контейнер + внутренний контейнер
3. Браузер может применять Scroll Anchoring **дважды**: для внешнего и внутреннего контейнера
4. Это усиливает эффект возврата к старой позиции

---

## 4️⃣ Визуальная схема процесса

### До открытия:
```
┌─────────────────────────────────┐
│ Заголовок секции "Naprawy..."  │ ← на позиции 1000px от верха
├─────────────────────────────────┤
│ Заголовок подкатегории "Oprog." │ ← на позиции 1100px от верха
│ [закрыто]                        │
├─────────────────────────────────┤
│ Заголовок подкатегории "Mech." │
│ [закрыто]                        │
└─────────────────────────────────┘
window.scrollY = 1000px
```

### После открытия (scrollSubcategoryToTop):
```
┌─────────────────────────────────┐
│ Заголовок секции "Naprawy..."  │ ← на позиции ~120px от верха viewport
├─────────────────────────────────┤
│ Заголовок подкатегории "Oprog."│ ← на позиции ~220px от верха viewport
│ ┌─────────────────────────────┐ │
│ │ Контент подкатегории       │ │ ← высота 800px
│ │ (таблицы, текст)           │ │
│ └─────────────────────────────┘ │
├─────────────────────────────────┤
│ Заголовок подкатегории "Mech." │
│ [закрыто]                        │
└─────────────────────────────────┘
window.scrollY = 1500px (прокрутили вниз на 500px)
Якорный элемент = заголовок подкатегории "Oprog."
```

### При закрытии (Scroll Anchoring):
```
┌─────────────────────────────────┐
│ Заголовок секции "Naprawy..."  │ ← на позиции ~120px от верха viewport
├─────────────────────────────────┤
│ Заголовок подкатегории "Oprog."│ ← якорный элемент
│ [закрыто]                        │ ← высота уменьшилась на 800px
├─────────────────────────────────┤
│ Заголовок подкатегории "Mech." │ ← подтянулся вверх
│ [закрыто]                        │
└─────────────────────────────────┘
window.scrollY = 700px (1500 - 800 = 700px)
Браузер автоматически прокрутил вверх на 800px, чтобы сохранить видимость якорного элемента
```

---

## 5️⃣ Итоговый ответ на вопрос

### Почему страница возвращается к виду "как до открытия"?

**Ответ:** Это происходит из-за механизма **Scroll Anchoring** в браузере, который автоматически корректирует позицию прокрутки при изменении высоты контента.

**Конкретные причины:**

1. ✅ **CSS анимация `animate-accordion-up`** уменьшает высоту `AccordionContent` от полной до 0
2. ✅ **Изменение высоты** активирует Scroll Anchoring в браузере
3. ✅ **Браузер определяет якорный элемент** (заголовок подкатегории или элемент рядом)
4. ✅ **Браузер автоматически прокручивает страницу вверх** на величину уменьшения высоты, чтобы сохранить видимость якорного элемента
5. ✅ **Результат:** `window.scrollY` уменьшается, визуально страница возвращается к позиции, близкой к той, что была до открытия

**Какая часть разметки или стилей заставляет viewport вернуться?**

1. **CSS класс `animate-accordion-up`** на `AccordionContent` — уменьшает высоту элемента
2. **Вложенная структура** с `overflow-y-auto` — усиливает эффект изменения высоты
3. **Механизм Scroll Anchoring браузера** — автоматически корректирует скролл при изменении высоты

**Важно:** Это **не программное вмешательство** в скролл (мы убрали всю такую логику), а **стандартное поведение браузера** для сохранения видимости контента при изменении высоты страницы.

---

## 6️⃣ Дополнительные наблюдения

### 6.1 Почему это не происходит при открытии?

При открытии мы **программно прокручиваем** страницу через `scrollSubcategoryToTop`, которая:
- Вызывает `window.scrollTo({ behavior: 'smooth' })`
- Это **переопределяет** Scroll Anchoring браузера
- Браузер следует нашей программной прокрутке, а не своему алгоритму

При закрытии:
- Мы **не вызываем** программную прокрутку
- Браузер применяет свой алгоритм Scroll Anchoring
- Результат: автоматическая корректировка скролла

### 6.2 Можно ли отключить Scroll Anchoring?

Теоретически можно использовать CSS свойство `overflow-anchor: none`, но это:
- Может вызвать другие проблемы (например, контент будет "прыгать" при загрузке)
- Не является стандартным решением для аккордеонов
- Может нарушить естественное поведение страницы

### 6.3 Альтернативные подходы

Чтобы предотвратить возврат к старой позиции, нужно:
1. **Сохранять позицию скролла** перед закрытием (что мы убрали)
2. **Восстанавливать позицию** после закрытия (что мы убрали)
3. Или использовать другой подход: **фиксировать позицию якорного элемента** относительно viewport

---

**Вывод:** Возврат к старой позиции происходит из-за **механизма Scroll Anchoring браузера**, который автоматически корректирует скролл при изменении высоты контента. Это стандартное поведение браузера, а не результат программного вмешательства.

